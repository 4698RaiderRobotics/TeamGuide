= Test Bench Examples
:source-highlighter: highlight.js
:xrefstyle: short
:stem:
:section-refsig: Exercise
:idprefix:
:idseparator: -
:tip-caption: WPILib:
:CPP: C++
:toc:

== Test Bench Description

The Test Bench was created to allow students wanting to learn FRC robot programming a way to do example problems without needing access to a functioning robot.  As you read these examples they will refer to terms and/or concepts that will not be familiar to you.  Stop and lookup what these unfamiliar terms/concepts mean as you go along.  

The test bench uses a https://docs.wpilib.org/en/stable/docs/software/roborio-info/roborio-introduction.html[RoboRIO 1] and a https://docs.wpilib.org/en/stable/docs/controls-overviews/control-system-hardware.html#ctre-power-distribution-panel[CTRE Power Distribution Panel].  It has two simple brushed motors (a https://www.andymark.com/products/neverest-classic-40-gearmotor[NeveRest with 40:1 gearbox] and a unknown motor) connected to two different motor controllers (a https://docs.wpilib.org/en/stable/docs/controls-overviews/control-system-hardware.html#spark-motor-controller[SPARK] and a https://docs.wpilib.org/en/stable/docs/controls-overviews/control-system-hardware.html#victor-sp[Victor SP]).  Both motor controllers are controlled with PWM. The "Position Control" motor is the NeveRest motor that is connected to a large disc.  The "Velocity Control" motor is the other small generic motor.

The "Velocity Control" motor is connected to the https://docs.wpilib.org/en/stable/docs/controls-overviews/control-system-hardware.html#victor-sp[Victor SP] motor controller which is wired into the roboRIO PWM channel 0.  It has a https://store.ctr-electronics.com/srx-mag-encoder/[SRX Mag Encoder] attached to its output shaft.  The SRX is wired into the roboRIO DIO channels 0, 1, and 2.  Channels 0 & 1 are the Quadrature A and B inputs and channel 2 is the absolute PWM signal.

The "Position Control" motor is connected to the https://docs.wpilib.org/en/stable/docs/controls-overviews/control-system-hardware.html#spark-motor-controller[SPARK] motor controller which is wired into the roboRIO PWM channel 1.  The position control motor has a built-in encoder and it also has a https://store.ctr-electronics.com/srx-mag-encoder/[SRX Mag Encoder] attached to its output shaft.  The SRX is wired into the roboRIO DIO channels 3, 4, and 5. Channels 3 & 4 are the Quadrature A and B inputs and channel 5 is the absolute PWM signal. The built-in encoder is wired into Channels 6 and 7.

The Test Bench does not have a WiFi radio so the coding computer must be connected to the roboRIO with a USB cable (USB A to USB B).  The Test Bench must also be powered by a robot battery.

.The Test Bench
image::img/TestBench.jpg[Test Bench, align="center"]

:sectnums:
== Percent Output Exercise

In this example we will be creating a "Timed Robot" program to set the position motor's percent output based on the position of a controller joystick.

Launch "WPILib VS Code" from the desktop.  This runs VS Code with the WPILib libraries and tools enabled. https://docs.wpilib.org/en/stable/docs/software/vscode-overview/creating-robot-program.html[Follow these directions to create a blank project from the "Timed Skeleton (Advanced)" template].

You should now have an empty project.  The two files that we will be working with are `src/main/include/Robot.h` and `src/main/cpp/Robot.cpp`.  Find those files in the Explorer on the left sidebar of VS Code and open `Robot.h`.  It contains the `Robot` class which declares (See https://www.learncpp.com/cpp-tutorial/forward-declarations/[Forward Declarations and Definitions]) the `Robot-`, `Autonomous-`, `Teleop-`, `Disabled-`, `Test-`, and `Simulation-` Init() and Periodic() functions.

.Contents of Generated Robot.h
[source,C++]
----
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

#pragma once

#include <frc/TimedRobot.h>

class Robot : public frc::TimedRobot {
 public:
  void RobotInit() override;
  void RobotPeriodic() override;

  void AutonomousInit() override;
  void AutonomousPeriodic() override;

  void TeleopInit() override;
  void TeleopPeriodic() override;

  void DisabledInit() override;
  void DisabledPeriodic() override;

  void TestInit() override;
  void TestPeriodic() override;

  void SimulationInit() override;
  void SimulationPeriodic() override;
};
----

For this simple example we won't need most of the Init() and Periodic() functions so delete all the declared functions except `RobotInit()`, `RobotPeriodic()` and `TeleopPeriodic()`.  `RobotInit()` runs once when the code first starts, `RobotPeriodic()` runs every 20 milliseconds at all times, and `TeleopPeriodic()` runs every 20 milliseconds while the Driver Station is in `TeleOperated` Mode.

We need to add member variables to the `Robot` class for our motor controller and for a joystick.  The motor controller on the position motor is a https://docs.wpilib.org/en/stable/docs/controls-overviews/control-system-hardware.html#spark-motor-controller[Spark] controller so we will be using the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_spark.html[`frc::Spark`] class.  Open the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_spark.html[`frc::Spark` class API documentation] which will show what methods are available with the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_spark.html[`frc::Spark`] class and what header needs to be included to use the class.  In the API documentation for https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_spark.html[`frc::Spark`] only the constructor that takes the PWM channel is shown along with the default constructor and the assignment operator.  Expand the `Public Member Functions inherited from frc::PWMMotorController` section to see more member functions that are available that are inherited from the `frc::PWMMotorController` class which is a base class of https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_spark.html[`frc::Spark`] (See xref:CPP_Lessons.adoc#object-orientation[Object Orientation]).  In `Robot.h` add a private section to the `Robot` class that declares a https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_spark.html[`frc::Spark`] variable and initialized the channel to one. Also add a https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_xbox_controller.html[`frc::XboxController`] variable initialized to port zero. Add the two headers that are needed for the new classes.

.Robot.h after changes
[source,C++]
----
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

#pragma once

#include <frc/TimedRobot.h>
#include <frc/motorcontrol/Spark.h>
#include <frc/XboxController.h>

class Robot : public frc::TimedRobot {
 public:
  void RobotInit() override;
  void RobotPeriodic() override;
  void TeleopPeriodic() override;
 private:
  frc::Spark m_motor{1};
  frc::XboxController m_controller{0};
};
----

The `src/main/cpp/Robot.cpp` file has the definitions of the Init() and Periodic() functions for the `Robot` class. Remove all the Init() and Periodic() functions except `RobotInit()`, `RobotPeriodic()`, and `TeleopPeriodic()`.  Now add the line shown below to `TeleopPeriodic()` which sets the motor percent output (-1 to 1 value) to the value of the X-axis on the controller.  You won't use `RobotInit()` and `RobotPeriodic()` just yet.

.Robot.cpp after modifications
[source,C++]
----
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

#include "Robot.h"

void Robot::RobotInit() {}
void Robot::RobotPeriodic() {}

void Robot::TeleopPeriodic() {
    // Set the motor percent output to the controller left x-axis value
  m_motor.Set( m_controller.GetLeftX() );
}

#ifndef RUNNING_FRC_TESTS
int main() {
  return frc::StartRobot<Robot>();
}
#endif
----

:tasknum: 0
* #TASK {counter:tasknum}# -- Compile (Build) the project with above changes added and make sure there are no errors.  Then connect to the test bench with a USB cable and power the test bench. Connect an Xbox Controller or a Logitech controller to the your laptop and run the Driver Station.  Now deploy the code to the roboRIO.  Select `TeleOperated` on the driver station and press `Enable`.  The left joystick's x-axis motion should now control the speed of the motor.

=== Adding an Encoder

We are going to add the built-in encoder to our program so we can see how much the motor has turned and how fast it is turning.  In `Robot.h`, use the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_encoder.html[`frc::Encoder`] class to declare a variable for the encoder on channels 3 and 4.

.Changes to Robot.h
[source,C++]
----
  // Add the following header:
#include <frc/Encoder.h>

... 

    // Add a private member variable such as:
  frc::Encoder m_enc{ 3, 4 };
----

=== Visualizing What is Happening

The `Shuffleboard` program is used to communicate with the roboRIO.  The roboRIO can send information to `Shuffleboard` and `Shuffleboard` can be used to send information to the roboRIO.  The https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_smart_dashboard.html[`frc::SmartDashboard`] class is one method to communicate with `Shuffleboard`.  We will use the *static* member functions of the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_smart_dashboard.html[`frc::SmartDashboard`] class to add information about the motor and the joystick position to `Shuffleboard`. 

[%collaspable]
****
*{CPP}* classes with *static* member functions are used like regular functions. You do not create instances of the class. See https://www.learncpp.com/cpp-tutorial/static-member-functions/[Static Member Functions]
****

Modify `Robot.cpp` to the following:

[source,C++]
----
#include "Robot.h"
#include <frc/smartdashboard/SmartDashboard.h>

void Robot::RobotInit() {
  frc::SmartDashboard::PutData( "Velocity Motor", &m_motor );
  frc::SmartDashboard::PutNumber( "Encoder Distance", 0.0 );
  frc::SmartDashboard::PutNumber( "Joystick X-axis", 0.0 );
}

void Robot::RobotPeriodic() {
    // Get the current encoder distance and send it to the
    // SmartDashboard.
  double enc_dist = m_enc.GetDistance();
  frc::SmartDashboard::PutNumber( "Encoder Distance", enc_dist );
}

void Robot::TeleopPeriodic() {
    // Get the controller Left stick X-axis value
  double x_axis = m_controller.GetLeftX();

    // Send the value to the SmartDashboard
   frc::SmartDashboard::PutNumber( "Joystick X-axis", x_axis );

    // Set the motor percent output to the controller x-axis value
  m_motor.Set( x_axis );
}

#ifndef RUNNING_FRC_TESTS
int main() {
  return frc::StartRobot<Robot>();
}
#endif
----

* #TASK {counter:tasknum}# -- Compile and deploy the code to the test bench.  Run Shuffleboard and select the "SmartDashboard" tab.  Move the motor disc by hand and observe the encoder value changing.  Now select `TeleOperated` in the Driver Station and `Enable` the roboRIO.  As you move the joystick, `Shuffleboard` will display the joystick output, the motor percent output (which should be the same), and the encoder distance.

=== Encoder Values

The encoder values displayed on Shuffleboard are obtained with the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_encoder.html[`frc::Encoder`] `GetDistance()` function. By default, encoders return distance in raw "counts" which can vary between a few counts per revolution up to 4096 or more depending on the resolution of the encoder.  Approximate how many "counts" the encoder has per revolution by rotating the disc one full revolution (with the joystick) and determining the change in the distance measurement.  For this motor the number of "counts" per revolution should come out to be 1024.

When programming the robot we want to work with more meaningful units than raw counts.  If the mechanism is an arm that will move less than a full revolution then we probably want to use degrees.  If the mechanism is a spinning flywheel then we probably want to use revolutions. The https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_encoder.html[`frc::Encoder`] class has a member function called `SetDistancePerPulse()` which allows you to change the units returned by the `GetDistance()` function.  

* #TASK {counter:tasknum}# -- Modify the code to use rotations by adding the following to the `RobotInit()` function:

.Changing Encoder Units
[source,C++]
----
    // Add SetDistancePerPulse() function call to RobotInit()
    // Converts a 1024 count per revolution encoder to read rotations
  m_enc.SetDistancePerPulse( 1.0 / 1024 );
----

Deploy and run the robot code with the `SetDistancePerPulse()` function call added and note the units displayed in Shuffleboard.  The encoder distance shown in Shuffleboard should now be rotations.

== Position Control Exercise

The Percent Output Example (<<percent-output-exercise>>) above is the most simplistic way of controlling a motor.  Percent output control cannot perform the kinds of control that are needed for almost all robotic systems.  This project will move a motor to a specified position and hold it there.  It will use P-control (position-control) to maintain the desired position which is a *feedback* control algorithm.

If you haven't already, read the xref:README.adoc#motion-control[Motion Control] section and watch the "PID Video, Part 1" in the first part of that section.  This example builds on the project that was created in <<percent-output-exercise>> so you will need the code from that project. If you have used the `SetDistancePerPulse()` function as outlined in <<encoder-values>> then comment out the function call so that the encoder reads "counts".

=== P-Controller

The video in the first part of the xref:README.adoc#motion-control[Motion Control] section does a good job of describing what a P-controller does but I will reiterate it here.  The idea is to measure the current position of the robot mechanism (*y*) and then take the difference between the desired position (*r*) and the current position (*y*), this is the current position error (*e*).  We then set the motor percent output to the error (*e*) multiplied by a constant (*K~p~*) to scale things correctly.

[.text-center]
****
Motor Output = *K~p~* * *e* = *K~p~* * ( *r* - *y* )
****

:tasknum: 0
* #TASK {counter:tasknum}# -- Modify the code to hold the position 0 while the button *A* is held down and then move to the position 500 when the *B* button is held down.  When neither button is held then it should just stop the motor.  Write the P-controller yourself as is done in video "PID Video, Part 1" in the xref:README.adoc#motion-control[Motion Control] section. A good starting value for *K~p~* is to take the total distance that the motor has to move from one setpoint to the other (500 in this case) and take the inverse of that number ( 1.0 / 500 ).  So as a first guess, the value of *K~p~* should be 0.002.

.Pseudocode for P-Controller
[subs=normal]
----
    If *Button A* is held::
      error = 0 - { encoder position }
      set motor output to (K~p~ * error)
    Else If *Button B* is held::
      error = 500 - {encoder position}
      set motor output to (K~p~ * error)
    Else
      set motor output to zero
    End If
----

This logic will go in the `TeleopPeriodic()` method. Change the value of the  *K~p~* constant and observe the difference in behavior of the mechanism.

* #TASK {counter:tasknum}# -- Modify the units given by the encoder as demonstrated in <<encoder-values>> to use rotations.  Have Button *A* still go to 0 but change Button *B* to go to 2 rotations.  How does this affect the value of the *K~p~* constant?

=== Shuffleboard Graphs

Read the https://docs.wpilib.org/en/stable/docs/software/dashboards/shuffleboard/index.html[Shuffleboard^] documentation and in particular https://docs.wpilib.org/en/stable/docs/software/dashboards/shuffleboard/getting-started/shuffleboard-graphs.html[Working with Graphs].

* #TASK {counter:tasknum}# -- Graph the desired position and the actual encoder position in `Shuffleboard` as you move from the 0 position to the 500 position and back.  Note whether the actual position gets exactly to the desired position.

=== Relative Encoder Limitations

Disable the robot and manually move the position motor to a new position then restart the robot code by going to `Diagnostics -> Restart Robot Code` in the Driver Station.  Rerun the code and notice that the 0 position (and 500 position) are not in the same location as the last time the code was run. This is due to the fact that the encoder we are using is a relative encoder that does not really know where the motor shaft position is but only know how far it has moved from the last time is was powered on.

=== Homing Switch

A homing switch can be used to put a motor with a relative encoder into a known location.  This is commonly done on CNC mills and routers that use stepper motors.  Currently the Test Bench does not have a homing switch to use.

=== Absolute Encoder

* #TASK {counter:tasknum}# -- Modify the code to use the SRX Mag Encoder's absolute PWM signal to always move to the same 0 position. https://store.ctr-electronics.com/content/user-manual/Magnetic%20Encoder%20User%27s%20Guide.pdf[SRX Mag Hardware Guide]  Use the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_duty_cycle_encoder.html[`frc::DutyCycleEncoder`] class. 

=== Real Angular Units

* #TASK {counter:tasknum}# -- Modify the code to move to locations based on angles in degrees.  You will need to determine the units that are returned from the encoder class that you are using (e.g. `frc::DutyCycleEncoder` or `frc::Encoder`).

=== PID Controller Class

* #TASK {counter:tasknum}# -- Use the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc2_1_1_p_i_d_controller.html[`frc2::PIDController`] class to implement the P-control.

== Velocity Control Exercise

TIP: https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/tuning-flywheel.html[Tuning a Flywheel Controller]

== Trapezoidal Motion Exercise

In <<position-control-exercise>> if the current motor position was very far from the desired position, then the motor would be immediately set to full power (100% output) toward the new desired position.  This results in very abrupt and jerky movements of the mechanism.  A better way to move the motor is to smoothly accelerate the motor towards the *goal* position until we reach a "cruise" velocity and then as we get close to the *goal* position we smoothly decelerate to a stop.  This type of motion is called a trapezoidal motion profile because the plot of the velocity during the motion is a trapezoid.

.Trapezoid Profile (from CTRE Docs)
image::https://v5.docs.ctr-electronics.com/en/stable/_images/closedlp-1.png[]

The WPILib provides the https://github.wpilib.org/allwpilib/docs/release/cpp/classfrc_1_1_trapezoid_profile.html[`frc::TrapezoidProfile<Distance>`] class to generate a trapezoidal motion profile.  It is a template class templated on either an angular unit or a distance unit.  The WPI Documenation describes https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/trapezoidal-profiles.html[using trapezoidal motion profiles]. 

:tasknum: 0
* #TASK {counter:tasknum}# -- Modify the <<position-control-exercise>> code to use a trapezoidal profile to move between a 0 degree position when *A* is held and 180 degrees when *B* is held.

